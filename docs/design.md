# Design Decisions

## Bennett's Notes

- Functions were fairly difficult to implement. They are essentially stored as their own list of lines for running a program. When you create a function, it will map the name of the function to the lines inside the function. Then, when you call the function it will just begin running a new binary plus program, which consists of the function lines.
- This means that a binary plus program takes in a namespace of variables and can return something. For the outer most scope, this does not matter since we are dealing with a mostly empty global namespace and we do not care about return types
- Function types and returns are enforced by the function itself
- If statements were honestly not that difficult. I just needed to add a new parameter when searching through lines to determine if we want to execute or not. When the if statement did not trigger, we could set execute=False, and thus ignore all the lines inside the if statement
- The above applies to else statements, we just toggle execute to either True or False depending on the original condition
- While loops were annoying. They should always bring the user back up to the stop to re-evaluate the expression
- To do this, I had to make sure that EVERY time we parsed and executed a line, it would return a new line number to move onto
- Most of the time this line number is just 1 more than the previous line number, but for while loops we had to keep track of the line number which marked the start, and instead we would return the starting line number
- The most fun part of programming this, for me, was definitely functions. Getting those working, along with taking parameters and returning values, was really fun, and I surprisingly did not have that much of a problem implementing it all, after I wrapped my head around a good way to store and execute them.
- Nested function calls were a bit of a pain. Nested function definitions were quite easy. The way I set up function definitions at first worked very well, and I could nest them immediately. But nested function calls were tough. Being able to call a line like `var int x = func1(1 + 2, func2(x, func1(1, 2), y))` took a really long time and far too much trouble
- The section of code that I had to keep changing over and over again was string creation. Being able to loop through the string and replace variables with their values had to change basically every time I added a new feature. I had a really good version at the start, but as we added more it kept breaking. We have settled on what I would consider a worse version, but at least it works for all variables and functions. The sad part is we cannout output function returns, instead we have to store those into another variable and output the variable. I definitely could fix this to be better, but then it would probably break some other section and it is not worth my time anymore

## Ben's Notes

- I decided to tackle the majority of the expression trees when it comes to parsing integer expressions and boolean expressions. I took compilers at the start of the pandemic and I wanted to try and see how much I was able to remember. It turns out expression trees are very difficult to wrap your head around (especially with all the recursion). Looking at my old notes, I was able to get the correct expression trees for integer expressions which accounted for precidence of each operator while maintaining one-token lookahead. However, boolean expressions were a bit harder as they could contain a boolean expression *or* an arithmetic expression. Between my other classes and life obligations, I wasn't able to get the parsing working exactly how I wanted so I scrapped the whole thing for something much simpler. If I were to come back to this, this is one thing I would want to heavily improve.
- One flaw I found with how Python does it's match statements is it is very difficult to tell if an operator is a binary or unary operator. As a result, I decided to only have binary operators be defined. Unary ones could then be created using a simple function.
- Getting the syntax for our language was also fun but difficult. After using Python and Javascript so much, I find myself often defaulting to how those language do things instead of making something new. As a result, I'm glad I partnered with Bennett who brought many interesting ideas to the table when defining the syntax. The `output` command is one of my favorites where it doesn't require quotes and automatically parses each word checking for variables. This design decision is harder to initially understand but from a technical level, I just found it really cool.
- I've also come to realize I really enjoy writing up documentation. Writing high-level overviews and tutorials with tables, examples, etc. is really enjoyable for some reason. I'm not sure why when I often find myself not finding the motivation to add docstrings to my code.
- Bennett and I really wanted to focus on Python 3.10's new `match` statement which roughly acts like an `if/elif/else` chain but with `switch`-like syntax and very powerful pattern matching. For the most part, the pattern matching worked great to parse out each line in the file. However, there were some issues where white space was needed (or the lack thereof) to do proper parsing. However, with all those issues I still find it very powerful (and a lot easier to read than regular expressions).
- I really liked how our function definitions included an anonymous function. While we didn't use this much in our final product, this could be extended to create some really powerful higher-order functions in the future.
